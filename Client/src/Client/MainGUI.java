package Client;

import Protocol.Client;
import Protocol.CommunicationProtocol;
import java.io.ByteArrayInputStream;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.MulticastSocket;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.DefaultListModel;
import javax.swing.JOptionPane;

public class MainGUI extends javax.swing.JFrame {
    ConnectToServerDialogGUI connectToServerDialog;
    private String nameCliente;
    private String pathToSharedDirectory;
    private String ipOwnerSharedDirectory;
    private File[] ficheirosPartilhados;
    private int portServer;
    private int portFiles;
    private int portNetwork;
    private InetAddress ipServerInet;
    private String grupoMulticast;
    private MulticastSocket multicastSocket;
    private ServerSocket serverNetworkSocket;
    private int grupoMulticastPorto;
    private List<Client> clientesLigados;
    private Client clienteSelecionado;
    private volatile boolean running = true;
    private Thread listenMulticastThread;
    private Thread listenFileThread;
    private ScheduledExecutorService scheduler;
    private DefaultListModel<String> notificationModel;
    

    /**
     * Creates new form NewJFrame
     */
    public MainGUI() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jDialog1 = new javax.swing.JDialog();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jPanel1 = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        listaUtilizadoresAtivos = new javax.swing.JList<>();
        ligarServerButton = new javax.swing.JButton();
        verPastaPartilhada = new javax.swing.JButton();
        transferirFicheiroButton = new javax.swing.JButton();
        desligarServerButton = new javax.swing.JButton();
        atrasButton = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        notificationList = new javax.swing.JList<>();
        jPanel3 = new javax.swing.JPanel();
        jScrollPane3 = new javax.swing.JScrollPane();
        ficheirosDePastaPartilhadaJList = new javax.swing.JList<>();

        javax.swing.GroupLayout jDialog1Layout = new javax.swing.GroupLayout(jDialog1.getContentPane());
        jDialog1.getContentPane().setLayout(jDialog1Layout);
        jDialog1Layout.setHorizontalGroup(
            jDialog1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        jDialog1Layout.setVerticalGroup(
            jDialog1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        listaUtilizadoresAtivos.setFont(new java.awt.Font("Segoe UI", 0, 18)); // NOI18N
        jScrollPane2.setViewportView(listaUtilizadoresAtivos);

        ligarServerButton.setText("Connect to Server");
        ligarServerButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ligarServerButtonActionPerformed(evt);
            }
        });

        verPastaPartilhada.setText("View Shared Folder");
        verPastaPartilhada.setEnabled(false);
        verPastaPartilhada.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                verPastaPartilhadaActionPerformed(evt);
            }
        });

        transferirFicheiroButton.setText("Transfer File");
        transferirFicheiroButton.setEnabled(false);
        transferirFicheiroButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                transferirFicheiroButtonActionPerformed(evt);
            }
        });

        desligarServerButton.setText("Disconnect from Server");
        desligarServerButton.setEnabled(false);
        desligarServerButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                desligarServerButtonActionPerformed(evt);
            }
        });

        atrasButton.setText("Back");
        atrasButton.setEnabled(false);
        atrasButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                atrasButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap(49, Short.MAX_VALUE)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 660, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(ligarServerButton, javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(transferirFicheiroButton, javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(desligarServerButton, javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(verPastaPartilhada, javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(atrasButton, javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(29, 29, 29))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap(36, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(ligarServerButton, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(verPastaPartilhada, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(transferirFicheiroButton, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(desligarServerButton, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(atrasButton, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 502, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(28, 28, 28))
        );

        jTabbedPane1.addTab("Connections", jPanel1);

        notificationList.setFont(new java.awt.Font("Segoe UI", 0, 18)); // NOI18N
        jScrollPane1.setViewportView(notificationList);

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 872, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 554, Short.MAX_VALUE)
                .addContainerGap())
        );

        jTabbedPane1.addTab("Notifications", jPanel2);

        ficheirosDePastaPartilhadaJList.setFont(new java.awt.Font("Segoe UI", 0, 18)); // NOI18N
        jScrollPane3.setViewportView(ficheirosDePastaPartilhadaJList);

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 884, Short.MAX_VALUE)
            .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel3Layout.createSequentialGroup()
                    .addGap(118, 118, 118)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 660, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(106, Short.MAX_VALUE)))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 566, Short.MAX_VALUE)
            .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel3Layout.createSequentialGroup()
                    .addGap(32, 32, 32)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 502, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(32, Short.MAX_VALUE)))
        );

        jTabbedPane1.addTab("Shared Folder", jPanel3);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTabbedPane1)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTabbedPane1)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void ligarServerButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ligarServerButtonActionPerformed
        connectToServerDialog = new ConnectToServerDialogGUI(MainGUI.this, true);
        connectToServerDialog.setVisible(true);
    }//GEN-LAST:event_ligarServerButtonActionPerformed

    private void transferirFicheiroButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_transferirFicheiroButtonActionPerformed
        System.out.println("Yo hice el pedido");
        int respostaSubstituirDialog = JOptionPane.OK_OPTION;
        int respostaTransferenciaDialog = JOptionPane.NO_OPTION;
        String fileSelected = listaUtilizadoresAtivos.getSelectedValue();
        
        //Verificar que o utilizador tenha selecionado realmente alguma coisa
        if(fileSelected == null){
            JOptionPane.showMessageDialog(null, "No file was selected, please try again", "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        //Dialog de transferencia
        respostaTransferenciaDialog = JOptionPane.showConfirmDialog(null, "Do you want to transfer the file?" + fileSelected + "?", "Transferir", JOptionPane.YES_NO_OPTION);
        
        if(respostaTransferenciaDialog == JOptionPane.NO_OPTION){
            return;
        }
        
        //Dialog de substituição
        for(File file : ficheirosPartilhados){
            if(file.getName().equals(fileSelected)){
                respostaSubstituirDialog = JOptionPane.showConfirmDialog(null, "The file already exists in your shared directory. Do you want to replace it?", "Replace file", JOptionPane.OK_CANCEL_OPTION);
            }
        }
        
        if(respostaSubstituirDialog == JOptionPane.CANCEL_OPTION){
            return;
        }
        
        //Pedir ficheiro
        try{
            Socket requestSocket = new Socket(ipOwnerSharedDirectory, clienteSelecionado.getNetworkPort());
            
            CommunicationProtocol requestMessage = new CommunicationProtocol("REQUEST_FILE");
            requestMessage.setFileForRequest(fileSelected);
            requestMessage.setPortForSendingFile(portFiles);
            
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(requestSocket.getOutputStream());
            objectOutputStream.writeObject(requestMessage);
            objectOutputStream.flush();
            objectOutputStream.close();
            
            requestSocket.close();
        }
        catch(Exception e){
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, "A problem occurred while transferring the file", "Error", JOptionPane.ERROR_MESSAGE);
        }
        
        //Recebir ficheiro
        try {
            ServerSocket serverSocket = new ServerSocket(portFiles);
            
            Socket responseSocket = serverSocket.accept();
            
            System.out.println("I am going to receive the file");
            InputStream inputStream = responseSocket.getInputStream();
            FileOutputStream fileOutputStream = new FileOutputStream(pathToSharedDirectory + "\\" + fileSelected);
            
            //Buffer para recebir o ficheiro
            byte[] buffer = new byte[1024];
            int bytesLidos;
            
            while((bytesLidos = inputStream.read(buffer)) != -1){
                fileOutputStream.write(buffer, 0, bytesLidos);
            }
            
            fileOutputStream.close();
            inputStream.close();
            serverSocket.close();
            responseSocket.close();
        
            //Indicar ao utilizador que a transferencia foi bem sucedida
            JOptionPane.showMessageDialog(null, "Transferência concluida", "Transferência", JOptionPane.INFORMATION_MESSAGE);
            
        } catch (IOException ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "Ocorreu um problema ao recebir o ficheiro", "ERRO", JOptionPane.ERROR_MESSAGE);
        }
        
        //Informar ao servidor da transferencia
        CommunicationProtocol transferReportMessage = new CommunicationProtocol("TRANSFER_REPORT");
        transferReportMessage.setSenderName(nameCliente);
        transferReportMessage.setTargetName(clienteSelecionado.getName());
        
        try {
            Socket socket = new Socket(ipServerInet, portServer);
            
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());
            ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());
            
            objectOutputStream.writeObject(transferReportMessage);
            objectOutputStream.flush();
            
            CommunicationProtocol response = (CommunicationProtocol) objectInputStream.readObject();
            if(response.getCodeProtocol().equals("OK")){
                System.out.println("Foi informado ao servidor da transferencia de ficheiros");
            }
            
            objectOutputStream.close();
            objectInputStream.close();
            socket.close();
        
        } catch (IOException | ClassNotFoundException ex) {
            Logger.getLogger(MainGUI.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_transferirFicheiroButtonActionPerformed

    private void desligarServerButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_desligarServerButtonActionPerformed
        //Abandonamos o grupo multicast primeiro para evitar que o servidor ao notificar do nosso logout
        //nos propios recebamos essa mensagem
        InetAddress grupoMulticastInet;
        try {
            grupoMulticastInet = InetAddress.getByName(grupoMulticast);
            multicastSocket.leaveGroup(grupoMulticastInet);
        } catch (IOException ex) {
            JOptionPane.showMessageDialog(null, "Ocorreu um problema ao abandonar o grupo multicast", "ERRO", JOptionPane.ERROR_MESSAGE);
        }
                   
        //Fazer request para logout ao servidor
        CommunicationProtocol logoutRequest = new CommunicationProtocol("LOGOUT");
        logoutRequest.setSenderName(nameCliente);
        
        try {
            Socket socket = new Socket(ipServerInet.getHostAddress(), portServer);
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());
            ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());
            
            objectOutputStream.writeObject(logoutRequest);
            objectOutputStream.flush();
            
            CommunicationProtocol response = (CommunicationProtocol) objectInputStream.readObject();
            if(response.getCodeProtocol().equals("OK")){
                JOptionPane.showMessageDialog(null, response.getMessage(), "SUCESSO", JOptionPane.INFORMATION_MESSAGE);
            }
            else{
                JOptionPane.showMessageDialog(null, "Ocorreu um erro ao realizar logout do servidor", "ERROR", JOptionPane.ERROR_MESSAGE);
            }
        
            //Fechar recursos
            objectOutputStream.close();
            objectInputStream.close();
            socket.close();
            
        } catch (IOException | ClassNotFoundException ex) {
            JOptionPane.showMessageDialog(null, "Erro ao comunicar com o servidor", "ERRO", JOptionPane.ERROR_MESSAGE);
        } 
        
        //Apagar os dados de sessão com o servidor
        nameCliente = "";
        portServer = -1;
        portFiles = -1;
        portNetwork = -1;
        ipServerInet = null;
        grupoMulticast = null;
        grupoMulticastPorto = -1;
        pathToSharedDirectory = "";
        ficheirosPartilhados = null;
        clientesLigados = null;
        
        ligarServerButton.setEnabled(true);
        verPastaPartilhada.setEnabled(false);
        transferirFicheiroButton.setEnabled(false);
        desligarServerButton.setEnabled(false);
        
        //Apagar os dados mostrados na listagem
        DefaultListModel<String> modelList = (DefaultListModel<String>) listaUtilizadoresAtivos.getModel();
        modelList.clear();
        notificationModel.clear();
        DefaultListModel<String> ficheirosModelList = (DefaultListModel<String>) ficheirosDePastaPartilhadaJList.getModel();
        ficheirosModelList.clear();
        
        //Deter as threads em funcionamento
        running = false;
        listenMulticastThread.interrupt();
        listenFileThread.interrupt();
        scheduler.shutdownNow();
        
        //Fechamos os sockets para obrigar as threads a fechar mesmo (Embora o codigo anterior envie interrupts e coloque running a false
        //as threads vão continuar detidas em socket.accept(), portanto fechamos os sockets para obrigalas a parar)
        try {
            multicastSocket.close();
            serverNetworkSocket.close();
        } catch (IOException ex) {
            Logger.getLogger(MainGUI.class.getName()).log(Level.SEVERE, null, ex);
        }
        
    }//GEN-LAST:event_desligarServerButtonActionPerformed

    private void verPastaPartilhadaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_verPastaPartilhadaActionPerformed
        String userSelected = listaUtilizadoresAtivos.getSelectedValue();
        String name = userSelected.split("-")[0].trim();
        ipOwnerSharedDirectory = userSelected.split("-")[1].trim();
        for(Client client : clientesLigados){
            if(client.getName().equalsIgnoreCase(name)){
                clienteSelecionado = client;
                java.awt.EventQueue.invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        DefaultListModel<String> modelList = new DefaultListModel<String>();
                        for(File files : client.getFiles()){
                            modelList.addElement(files.getName());
                        }
                        listaUtilizadoresAtivos.setModel(modelList);
                        atrasButton.setEnabled(true);
                        transferirFicheiroButton.setEnabled(true);
                        verPastaPartilhada.setEnabled(false);
                    }
                });
            }
        }
    }//GEN-LAST:event_verPastaPartilhadaActionPerformed

    private void atrasButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_atrasButtonActionPerformed
        //Atualizar lista
        java.awt.EventQueue.invokeLater(new Runnable(){
            @Override
            public void run() {
                DefaultListModel<String> modelList = new DefaultListModel<String>();
                for(Client client : clientesLigados){
                    modelList.addElement(client.getName() + " - " + client.getIpv4());
                }
                listaUtilizadoresAtivos.setModel(modelList);
                atrasButton.setEnabled(false);
                transferirFicheiroButton.setEnabled(false);
                verPastaPartilhada.setEnabled(true);
                ipOwnerSharedDirectory = "";
                clienteSelecionado = null;
            }
        
        });
    }//GEN-LAST:event_atrasButtonActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        int resposta = JOptionPane.showConfirmDialog(this, "Would you like to close the program?", "Exit Program", JOptionPane.YES_NO_CANCEL_OPTION);
        if(resposta == JOptionPane.YES_OPTION){
            if(ipServerInet != null){
                desligarServerButtonActionPerformed(null);
                System.exit(0);
            }
            else{
                System.exit(0);
            }
        }
    }//GEN-LAST:event_formWindowClosing

    public void recebirDadosLoginFromDialog(String aName, int aPortServer, int aPortFiles, int aPortNetwork, InetAddress aIpServerInet, String aGrupoMulticast, int aGrupoMulticastPorto, String aPathToSharedDirectory, List<Client> aClientesLigados, File[] aFicheirosPartilhados){
        //Obter dados
        nameCliente = aName;
        portServer = aPortServer;
        portFiles = aPortFiles;
        portNetwork = aPortNetwork;
        ipServerInet = aIpServerInet;
        grupoMulticast = aGrupoMulticast;
        grupoMulticastPorto = aGrupoMulticastPorto;
        pathToSharedDirectory = aPathToSharedDirectory;
        ficheirosPartilhados = aFicheirosPartilhados;
        clientesLigados = aClientesLigados;
        connectToServerDialog.setVisible(false);
        
        //Atualizar lista
        java.awt.EventQueue.invokeLater(new Runnable(){
            @Override
            public void run() {
                DefaultListModel<String> modelList = new DefaultListModel<String>();
                for(Client client : clientesLigados){
                    modelList.addElement(client.getName() + " - " + client.getIpv4());
                }
                listaUtilizadoresAtivos.setModel(modelList);
            }
        
        });
        
        //Iniciar o listening no grupo multicast
        running = true;
        listenMulticastThread = new Thread(new Runnable(){
            @Override
            public void run() {
                listenMulticastGroup();
            }
        });
        listenMulticastThread.start();
        
        //Iniciar o listening de pedidos de ficheiros
        listenFileThread = new Thread(new Runnable(){
            @Override
            public void run() {
                listenFileRequest();
            }
            
        });
        listenFileThread.start();
        
        //Verificar os ficheiros da pasta partilhada
        scheduler = Executors.newScheduledThreadPool(1);
        scheduler.scheduleAtFixedRate(new Runnable(){
            @Override
            public void run() {
                System.out.println("The file verifier was executed");
                verificarFicheirosPastaPartilhada(pathToSharedDirectory);
            }
            
        }, 0, 5, TimeUnit.SECONDS);
        
        //Mostrar os ficheiros da pasta partilhada
        atualizarListagemPastaPartilhada();
        
        //Preparar a area de notificacoes
        notificationModel = new DefaultListModel<>();
        notificationList.setModel(notificationModel);
        
        //Atualizar botoes
        ligarServerButton.setEnabled(false);
        verPastaPartilhada.setEnabled(true);
        transferirFicheiroButton.setEnabled(false);
        desligarServerButton.setEnabled(true);
    }
    
    private void listenMulticastGroup(){
        CommunicationProtocol message = null;
        try {
            multicastSocket = new MulticastSocket(grupoMulticastPorto);
            InetAddress grupoMulticastInet = InetAddress.getByName(grupoMulticast);
            multicastSocket.joinGroup(grupoMulticastInet);
            
            byte[] buffer = new byte[4096];
            DatagramPacket dp = new DatagramPacket(buffer, buffer.length);
            
            while(running){
                try{
                    multicastSocket.receive(dp);
                }
                catch(SocketException e){
                    continue;
                }
                
                //Deserializar o objeto
                ByteArrayInputStream byteStream = new ByteArrayInputStream(dp.getData());
                ObjectInputStream objectInputStream = new ObjectInputStream(byteStream);
                try {
                    message = (CommunicationProtocol) objectInputStream.readObject();
                } catch (ClassNotFoundException ex) {
                    JOptionPane.showMessageDialog(null, "Erro ao ler a mensagem enviada pelo servidor", "ERRO", JOptionPane.ERROR_MESSAGE);
                    continue;
                }
                
                //Processar a mensagem
                switch(message.getCodeProtocol()){
                    case "ACTIVE_CLIENTS_UPDATE":
                        clientesLigados = message.getActiveClients();
                        //Atualizar lista
                        java.awt.EventQueue.invokeLater(new Runnable(){
                            @Override
                            public void run() {
                                DefaultListModel<String> modelList = new DefaultListModel<String>();
                                for(Client client : clientesLigados){
                                    modelList.addElement(client.getName() + " - " + client.getIpv4());
                                }
                                listaUtilizadoresAtivos.setModel(modelList);
                            }

                        });
                        break;
                        
                    case "CLIENT_FILES_UPDATED":
                        //Guardamos a nova lista de clientes ligados (É nova porque algum utilizador mudou a sua lista de ficheiros partilhados)
                        clientesLigados = message.getActiveClients();
                        
                        //Se existe um cliente selecionado, atualizamos a lista de ficheiros que o utilizador
                        //esta a ver do mesmo. Caso contrario, a lista nova de ficheiros sera apresentada da proxima vez 
                        //quando o utilizador clicar no cliente que deseja ver
                        if(clienteSelecionado != null){
                            for(Client client : clientesLigados){
                                if(client.getName().equalsIgnoreCase(clienteSelecionado.getName())){
                                    clienteSelecionado = client;
                                    java.awt.EventQueue.invokeLater(new Runnable() {
                                        @Override
                                        public void run() {
                                            DefaultListModel<String> modelList = new DefaultListModel<String>();
                                            for(File files : client.getFiles()){
                                                modelList.addElement(files.getName());
                                            }
                                            listaUtilizadoresAtivos.setModel(modelList);
                                            atrasButton.setEnabled(true);
                                        }
                                    });
                                }
                            }
                        }
                        break;
                        
                    case "CLIENT_LIST_ALTERED":
                        //Guardamos a nova lista de clientes ligados (É nova porque algum utilizador fez logout e já não está listado)
                        clientesLigados = message.getActiveClients();
                        
                        //Caso o cliente selecionado não estiver em clientesLigados, quer dizer que o utilizador esta a ver a pasta partilhada
                        //de um utilizador que fez logout, portanto o retornamos a listagem de utilizadores novamente.
                        //
                        //Caso cliente selecionado seja null, então o utilizador esta na listagem de utilizadores e portanto fazemos update
                        //de essa listagem.
                        //
                        //O caso restante é que o utilizador esteja a ver a pasta partilhada de um outro utilizador que esta ativo e nesse
                        //caso não fazemos nada (As condições do if são relativas aos dois casos anteriores)
                        if(!clientesLigados.contains(clienteSelecionado) || (clienteSelecionado == null)){
                            //Atualizar lista
                            java.awt.EventQueue.invokeLater(new Runnable(){
                                @Override
                                public void run() {
                                    DefaultListModel<String> modelList = new DefaultListModel<String>();
                                    for(Client client : clientesLigados){
                                        modelList.addElement(client.getName() + " - " + client.getIpv4());
                                    }
                                    listaUtilizadoresAtivos.setModel(modelList);
                                    atrasButton.setEnabled(false);
                                    ipOwnerSharedDirectory = "";
                                    clienteSelecionado = null;
                                }

                            });
                        }
                        break;
                        
                    case "NOTIFICATION":
                        String notification = message.getMessage();
                        notificationModel.addElement(notification);
                        break;
                    default:
                        JOptionPane.showMessageDialog(null, "Não foi possivel entender a mensagem que o servidor enviou", "ERRO", JOptionPane.ERROR_MESSAGE);
                        break;
                }
                
            }
            
        } catch (IOException ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "Error connecting to the Multicast group", "ERROR", JOptionPane.ERROR_MESSAGE);
        }
    }
    
    private void listenFileRequest(){
        CommunicationProtocol request = null;
        try{
            serverNetworkSocket = new ServerSocket(portNetwork);
            
            while(running){
                Socket requestSocket;
                try{
                    requestSocket = serverNetworkSocket.accept();
                }
                catch(SocketException ex){
                    continue;
                }
                System.out.println("Yo recibi el pedido");
                ObjectInputStream objectInputStream = new ObjectInputStream(requestSocket.getInputStream());
                
                try{
                    request = (CommunicationProtocol) objectInputStream.readObject();
                }
                catch(EOFException e){
                    JOptionPane.showMessageDialog(null, "Ocorreu um problema ao procesar o pedido de ficheiro de um outro cliente", "ERRO", JOptionPane.ERROR_MESSAGE);
                }
                
                switch(request.getCodeProtocol()){
                    case "REQUEST_FILE":
                        String fileNameRequested = request.getFileForRequest();
                        int portForSendingFile = request.getPortForSendingFile();
                        
                        System.out.println("Estoy buscando el archivo para enviarlo");
                        File fileRequested = Files.walk(Paths.get(pathToSharedDirectory))
                                .filter(path -> Files.isRegularFile(path))
                                .filter(path -> path.getFileName().toString().equals(fileNameRequested))
                                .map(path -> path.toFile())
                                .findFirst()
                                .orElse(null);
                        
                        if(fileRequested != null){
                            System.out.println("El archivo no es null y su nombre es: " + fileRequested.getName());
                        }
                        else{
                            System.out.println("El archivo es null");
                        }
                        
                        
                        sendFileRequested(requestSocket.getInetAddress().getHostAddress(), portForSendingFile, fileRequested);
                        
                        if(fileRequested != null){
                            
                        }
                        
                        break;
                    default:
                        JOptionPane.showMessageDialog(null, "Foi recebido um pedido invalido de requisição de ficheiro", "ERRO", JOptionPane.ERROR_MESSAGE);
                        break;
                }
            }
        }
        catch(Exception e){
            JOptionPane.showMessageDialog(null, "Ocorreu um problema ao escutar na rede por pedidos de ficheiros", "ERRO", JOptionPane.ERROR_MESSAGE);
            e.printStackTrace();
        }
    }
    
    private void sendFileRequested(String ipDestino, int portoDestino, File fileForSending){
        try{
            //Definir socket e streams
            Socket socket = new Socket(ipDestino, portoDestino);
            FileInputStream fileInputStream = new FileInputStream(fileForSending);
            OutputStream outputStream = socket.getOutputStream();
            
            //Criar buffer para armazenar o ficheiro por partes
            byte[] buffer = new byte[1024];
            int bytesLidos;
            
            while((bytesLidos = fileInputStream.read(buffer)) != -1){
                outputStream.write(buffer, 0, bytesLidos);
            }
            
            outputStream.close();
            fileInputStream.close();
            socket.close();
        }
        catch(Exception e){
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, "Ocorreu um problema ao enviar o ficheiro", "ERRO", JOptionPane.ERROR_MESSAGE);
        }
    }
    
    private void verificarFicheirosPastaPartilhada(String pathToSharedDirectory){
        File[] filesScanned = null;
        try {
            filesScanned = Files.walk(Paths.get(pathToSharedDirectory))
                    .filter(path -> Files.isRegularFile(path))
                    .map(path -> path.toFile())
                    .toArray(size -> new File[size]);
        } catch (IOException ex) {
            Logger.getLogger(MainGUI.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        if(Arrays.asList(filesScanned).containsAll(Arrays.asList(ficheirosPartilhados)) && Arrays.asList(ficheirosPartilhados).containsAll(Arrays.asList(filesScanned)) ){
            return;
        }
        else{
            System.out.println("Las pastas son diferentes");
            //Atualizar listagem local de pasta partilhada
            ficheirosPartilhados = filesScanned;
            atualizarListagemPastaPartilhada();
            
            //Comunicar na rede a alteracao da pasta partilhada
            try {
                //Definir mensagem
                CommunicationProtocol updateFilesRequest = new CommunicationProtocol("UPDATE_FILES");
                updateFilesRequest.setFilesForUpdate(filesScanned);
                updateFilesRequest.setSenderName(nameCliente);
                        
                //Definir socket e streams
                Socket socket = new Socket(ipServerInet, portServer);
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());
                ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());
                
                //Enviar dados
                objectOutputStream.writeObject(updateFilesRequest);
                objectOutputStream.flush();
                
                //Receber resposta
                CommunicationProtocol response;
                response = (CommunicationProtocol) objectInputStream.readObject();
                if(response.getCodeProtocol().equalsIgnoreCase("OK")){
                    System.out.println("Ficheiros atualizados corretamente");
                }
                
                //Fechar recursos
                objectOutputStream.close();
                objectInputStream.close();
                socket.close();
                
                //Atualizar pasta local
                ficheirosPartilhados = filesScanned;
                
            } 
            catch (IOException | ClassNotFoundException ex) {
                JOptionPane.showMessageDialog(null, "Problema ao informar dos novos ficheiros ao servidor", "ERROR", JOptionPane.ERROR_MESSAGE);
            } 
        }
    }
    
    private void atualizarListagemPastaPartilhada(){
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                DefaultListModel<String> modelList = new DefaultListModel<String>();
                for(File files : ficheirosPartilhados){
                    modelList.addElement(files.getName());
                }
                ficheirosDePastaPartilhadaJList.setModel(modelList);
            }
        });
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MainGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MainGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MainGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new MainGUI().setVisible(true);
            }
        });
        
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton atrasButton;
    private javax.swing.JButton desligarServerButton;
    private javax.swing.JList<String> ficheirosDePastaPartilhadaJList;
    private javax.swing.JDialog jDialog1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JButton ligarServerButton;
    private javax.swing.JList<String> listaUtilizadoresAtivos;
    private javax.swing.JList<String> notificationList;
    private javax.swing.JButton transferirFicheiroButton;
    private javax.swing.JButton verPastaPartilhada;
    // End of variables declaration//GEN-END:variables
}
